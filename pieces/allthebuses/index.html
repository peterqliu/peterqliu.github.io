
<html>
<head>
    <meta charset='utf-8' />
    <title>allthebuses</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/94/three.min.js'></script>

    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.6.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.54.0/mapbox-gl.css' rel='stylesheet' />
    <style>

        :root {
            --IB: rgba(170, 51, 69, 1);
            --OB: rgba(65, 166, 178, 1);
        }

        body { 
            margin:0; 
            padding:0; 
            font-family: 'Open Sans', Verdana, sans-serif;
            overflow:hidden;
        }

        #map, #overlay { 
            position:absolute; 
            top:0; 
            bottom:0; 
            width:100%; 
            background:#B8C8D3;
        }
        /*#controls { position:absolute; top:0; left:0; }*/

        #back {
            z-index: 99;
            opacity:0.8;
            margin:1%;
            cursor:pointer;
            display:none;
            transition:all 0.1s;
            transform-origin: center;
        }

        #back:hover {
            transform:scale(1.25);
            opacity:1;
        }
        canvas {
            cursor:auto;
        }
        .mapboxgl-map {
            font-family: inherit
        }

        .mapboxgl-popup-content {
            padding:20px;
            font-size:1.25em;
            border-radius: 5px;   
            color:#bbb;
            box-shadow: 0 2px 8px rgba(186, 180, 157, 1);
            pointer-events: none;
            transition:transform 0.1s;
        }

        .title {
            font-weight:100;
            font-size:1.5em;
            color:#666;
            line-height: 1.5em;
        }

        .subtitle {
            font-weight:100;
            font-size:0.8em;
            color:#666;
            line-height: 1.5em;   
        }
        .IB .highlight {
            color: var(--IB);
        }        

        .OB .highlight {
            color: var(--OB);
        }


        #loader {
            z-index: 99;
            width:100%;
            height:100%;
            /*display: none;*/
            backdrop-filter: blur(50px);
            position: absolute;
            pointer-events: none;
            transition:opacity 2s;
        }

/*        .blurred + #map{
            pointer-events: none
        }*/


        #spinner {
            z-index: 99;
            width:15vh;
            height:15vh;
            margin-left:50vw;
            margin-top:50vh;
            background: #aa3345;
            transform-origin: center;
            animation-duration: 1.2s;
            animation-iteration-count: infinite;
            transform-origin: center;
            fill-opacity:0.8;
            border-radius: 50%;
            border-top-right-radius: 0%;
            position:absolute;
            animation-name: spinner;

        }

        #modal {
            position:absolute;
            bottom:0;
            right:0;
            background:white;
            margin:2vh;
            box-shadow: 0 2px 8px rgba(186, 180, 157, 1);
            border-radius:10px;
            font-size:2em;
            z-index: 90;
            max-height:96vh;
            overflow:scroll;
        }

        .view {
            padding:30px;
        }
        .modalSmall {
            font-size: 0.5em;
            color:#aaa;
        }

        .strong {
            color:#999
        }
        .bar {
            height: 4px;
            width: 100%;
            border-radius: 2px;
            overflow: visible;
            opacity:0.8;
            margin:5px 0px;
            background: #eee;
            position:relative;
        }

        #inboundBar {
            background:var(--IB);
            float: right;
            text-align: right;
            width: 40%;
            height: 100%;
        }

        .stopHash {
            width:1px;
            height:4px;
            border-radius:2px;
            background:#ccc;
            /* display:inline; */
            position:absolute;
        }
        .marker {
            display: inline-block;
            width: 9px;
            height: 9px;
            border-radius: 50%;
            border-top-right-radius: 0px;
            margin-left:2px;
        }

        .ib.marker {
            background: var(--IB);
            transform: rotate(45deg);
        }

        .ob.marker {
            background: var(--OB);
            transform: rotate(-135deg);
        }

        .quiet {
            opacity:0.75;
        }
        @-webkit-keyframes spinner {
            0% {
                transform: translateX(-50%) translateY(-50%) rotate(0deg);
            }

            100% {
                transform: translateX(-50%) translateY(-50%) rotate(450deg) ;
            }
        }

        #routeFocus {
            display:none;
        }
        body[mode='focus'] #routeFocus {
            display:block;
        }

        body[mode='focus'] #general {
            display:none;
        }

        .route {
            border-top:1px solid #eee;
            padding:15px;
        }

        .lines {
            /* margin:2vh; */
        }
        .line {
            margin-top:15px;
        }
    </style>
    <body mode='loading'>
        <div id='loader' class='blurred'>
            <div id='spinner' ></div>
        </div>
        <div id='map'>
            <div id='modal'>
                <div id='general'>
                    <div class="view">
                        <div class='title'>Muni, this moment</div>
                        <div class='bar' style="background: var(--OB)">
                            <div id="inboundBar"></div>
                        </div>
                        <div class='modalSmall'>
                            <span class='ob marker'></span>
                            <span id='ob'></span> Outbound
                            <span style='float:right'>
                                <span id='ib'></span> 
                                Inbound 
                                <span class='ib marker' 
                                    style=' margin-right:2px'
                                ></span>
                            </span>
                        </div>
                    </div>

                    <div id='routeList'>
                    </div>       
                </div>
         
                <div id='routeFocus'>
                    <div class='title'></div>
                </div>

            </div>            
        </div>

        <img src='src/zoomout.svg'id='back' onclick='app.setState("mode", "inactive"); app.map.fitBounds(c.fullBounds, {duration:500})'/>
    </body>
    <script src='../credentials.js'></script>

    <script src='src/map.js'></script>
    <script src="https://unpkg.com/cheap-ruler@3.0.1/cheap-ruler.min.js"></script>

    <script src="src/constants.js"></script>
    <script>

        mapboxgl.accessToken = config.token;//'pk.eyJ1IjoicGV0ZXJhZnRlcm1hcGJveCIsImEiOiJjbHZuN3U4cTgwYXA3MmpubmUzZjd6MHZzIn0.td7c9rfhH61htRk5OUWMSg';

        const app = {

            init: () => {
                pollBuses(true)
                setInterval(()=>pollBuses(), 5000)

                // build shape primitive and load font
                const loader = new THREE.FontLoader();

                loader.load( 'src/Open Sans_Regular.json', font => {

                    c.font = font;
                    app.setState('initFont', true);

                } );

                const x = 0, y = 0;

                const markerShape = new THREE.Shape();
                markerShape.arc(0, 0, 1, Math.PI/2, 0, false);
                markerShape.lineTo(x+1, y+1);

                c.geometry.bus = new THREE.ShapeGeometry( markerShape );
                c.geometry.bus.matrixAutoUpdate = false;
            },

            ruler: new CheapRuler(s.center[1], 'meters'),

            updateModal: function() {
                
                const routeSet = {};
                s.buses
                    .map(({route, direction, dir:{id, dirName}, lon, lat})=>({...route, direction, id, dirName, lngLat:[lon, lat]}))
                    .forEach(({name, direction, id, lngLat, dirName})=>{
                        if (!routeSet[name]) routeSet[name] = {IB:0, OB:0, lines:{}}
                        if (!routeSet[name].lines[id]) {
                            const [line, dir, variant] = id.split('_');
                            routeSet[name].lines[id] = {dirName, direction, buses: [], data: c.routeData[line][id]}
                        };

                        const pathPoints = routeSet[name].lines[id].data.path.geometry.coordinates;
                        routeSet[name].lines[id].buses.push(app.ruler.pointOnLine(pathPoints, lngLat).t)
                        routeSet[name][direction]++
                    })

                console.log(routeSet)

                // route entry
                const routes = d3.select('#routeList')
                    .selectAll('.route')
                    .data(Object.keys(routeSet).sort().map(route=>({route, ...routeSet[route]})))
                    .enter()
                    .append('div')
                    .classed('route', true);

                routes
                    .append('div')
                    .classed('subtitle', true)
                    .text(d=>d.route);


                // lines per route
                const lines = routes
                    .append('div')
                    .attr('class', 'lines')
                    .selectAll('.line')
                    .data(d=>{
                        return Object.entries(d.lines)
                    })

                    .enter()
                    .append('div')
                    .classed('line', true);

                // stop hashes
                const stopMarkers = lines.append('div')
                    .classed('bar', true)
                    .selectAll('.stopHash')
                    .data(([id, data])=>{
                        return data.data.stopDistances
                    })
                    .enter()
                    .append('div')
                    .classed('stopHash', true)
                    .attr('style', d=>`margin-left:${d*100}%`)

                const busMarkers = lines.select('.bar')
                    .selectAll('.marker')
                    .data(([id, data])=>data.buses.map(b=>({b, direction:data.direction})))
                    .enter()
                    .append('div')
                    .attr('class', d=>`quiet ${d.direction.toLowerCase()} marker`)
                    .style('margin-top', '-2px')
                    .style('position', 'absolute')
                    .style('margin-left', d=>`${(d.direction==='IB' ? d.b : 1-d.b)*100}%`)

                lines.append('div')
                    .html(([id, data])=>{
                        const [line, direction, variant] = id.split('_');
                        return `<span class="strong">${parseFloat(direction) ? 'Inbound' : 'Outbound'}</span> to ${app.format.dirName(data.dirName)}`
                    })
                    .classed('modalSmall', true)

                if (s.mode === 'inactive') {
                    d3.select()
                }

                else {

                }
            },
            getPrediction: (route, stop, cb) => {
                const url = `stopcodes/1${stop}/predictions`;

                app.utils.load(url, (r)=>{
                    const routeMatch = r.find(prediction=>prediction.route.id===route);
                    const predictions = routeMatch.values.map(v=>({seconds:(v.timestamp-Date.now())/1000, occupancy:v.occupancyDescription}))
                    cb(predictions || undefined);
                })

            },

            format: {
                time: (seconds) => {
                    let prediction;
                    if (!seconds) prediction = 'no current prediction'
                    else if (seconds>180) return `${Math.round(seconds/60)} minutes`
                    else if (seconds>60) {
                        const [minutes, secondRemainder] = [Math.floor(seconds/60), Math.round(seconds%60)];
                        return `${minutes}:${secondRemainder<10 ? 0 :''}${secondRemainder}`
                    }
                    else if (seconds>5) return `${Math.round(seconds)} seconds`
                    else return `approaching now`
                },

                occupancyString(raw) {
                    return raw.toLowerCase().replace('room ', '')
                },

                speed(kph) {
                    return kph ? 'moving at ' +Math.round(kph*0.621371) +' mph' : 'momentarily stopped'
                },
                
                dirName(raw) {
                    let formatted = raw.replace(' from', ', from').replace('+', '&')
                    if (formatted.length>30) formatted = formatted
                        .replace(/Avenue/g, '')
                        .replace(/Street/g, '')

                        .replace('Ave', '')
                        .replace('St ', '')
                    return formatted
                }
            },
            formatTime: (seconds) => {
                let prediction;
                if (!seconds) prediction = 'no current prediction'
                else if (seconds>180) return `${Math.round(seconds/60)} minutes`
                else if (seconds>60) {
                    const [minutes, secondRemainder] = [Math.floor(seconds/60), Math.round(seconds%60)];
                    return `${minutes}:${secondRemainder<10 ? 0 :''}${secondRemainder}`
                }
                else if (seconds>5) return `${Math.round(seconds)} seconds`
                else return `approaching now`
            },

            setState: (key, value) => {

                if (key === 'activeRoute'){

                    const {route, direction, dir} = value;
                    var newRoute = value ? [route.id, direction, dir.id] : false

                    //if already highlighting
                    if (s.activeRoute){

                        if (newRoute){
                            if (newRoute !== s.activeRoute) s.activeRoute = newRoute
                        }

                        else s.activeRoute = newRoute
                    }

                    //if no previous highlight
                    else if (newRoute) s.activeRoute = newRoute


                    updateRoute();
                }

                else if (key === 'mode') {

                    s.mode = value;
                    // document.querySelector('body').setAttribute('mode', value)
                    
                    // apply map styling for current mode
                    c.style[value].forEach(style => {
                        app.map.setPaintProperty(style[0], style[1], style[2])
                    })

                    // update back button visibility
                    document.querySelector('#back').style.display = value === 'focus' ? 'block' : 'none'

                    if (value === 'inactive') s.customLayer.restoreBusMarkerColors()
                    // else if (value === 'focus')
                }


                else if (key.includes('init')) {

                    s[key] = value;

                    if (s.initScene === s.initFont === true) {

                        document.querySelector('#loader').style.opacity = 0

                        app.map
                            .on('mousemove', (e)=>{app.on.mouseMove(e)} )
                            .on('click', s.customLayer.onClick)
                            .on('zoom', app.on.zoom) 
                    }

                }
            },

            map: new mapboxgl.Map({
                container: 'map', // container id
                antialiased:true,
                style: 'mapbox://styles/mapbox/light-v11',

                // style: 'mapbox://styles/peterqliu/cjnnukhkb08fu2so0ywo37ibj',
                center: s.center, // starting position
                // minZoom: 12,
                zoom: s.zoom // starting zoom
            }),

            popup: new mapboxgl.Popup({ 
                closeButton: false, 
                offset:25, 
                maxWidth:'none' 
            }),

            clearPopup: () => {
                app.popup.remove()
            },
            
            utils: {

                degreeify: radians =>{
                    radians = radians || 0;
                    return radians * 360/(Math.PI*2)
                },

                radify: deg => 2*Math.PI * deg/360,

                load: (queryString, cb) => {
                    const url = 'https://webservices.umoiq.com/api/pub/v1/agencies/sfmta-cis/';
                    const token = '?key=0be8ebd0284ce712a63f29dcaf7798c4';
                    s.requestsInFlight++;
                    return fetch([url, queryString, token].join(''))
                        .then(response => response.json())
                        .then(data=> {
                            s.requestsInFlight--
                            cb(data)
                        })
                },

                getDirection: str => {
                    var output = str.includes('_0_') ? 'OB' : 'IB'
                    return output
                },
                
                projectToScene: lngLat => {

                    const lng = lngLat.lng;

                    const xMercatorDelta = (lngLat[0]-s.center[0])/360;
                    const yMercatorDelta = 0.5 - 0.5 * Math.log(Math.tan(Math.PI * (1/4 + lngLat[1]/360)))/Math.PI - c.sceneTranslate.y

                    return new THREE.Vector3(xMercatorDelta, yMercatorDelta, Math.random()/10000000)
                }
            },

            on: {
                mouseMove: e => {

                    const cL = s.customLayer;

                    const mouse = new THREE.Vector3(
                        ( e.point.x / window.innerWidth ) * 2 - 1,
                        - ( e.point.y / window.innerHeight ) * 2 + 1,
                        1
                    )

                    const camInverseProjection = new THREE.Matrix4().getInverse(cL.camera.projectionMatrix);
                    const cameraPosition = new THREE.Vector3().applyMatrix4(camInverseProjection);
                    const mousePosition = mouse.applyMatrix4(camInverseProjection);
                    const viewDirection = mousePosition.clone().sub(cameraPosition).normalize();        

                    cL.raycaster.set(cameraPosition, viewDirection)
                    const intersect = cL.raycaster.intersectObjects( s.mesh.markers)[0];
                    
                    cL.highlightMarker(intersect ? intersect.object : undefined)
                
                    if (s.mode === 'focus' && !intersect) {
                        const hoveredStop = app.map
                            .queryRenderedFeatures(e.point, {layers:['stops']})[0];

                        cL.highlightStop(hoveredStop)
                        if (!hoveredStop) app.popup.remove()

                    }
                    
                },

                zoom: () =>{
                    const shouldShowLabels = app.map.getZoom() >= c.labelZoomThreshold;
                    
                    if (shouldShowLabels !== s.showLabels) {
                        console.log('changing')
                        const scale = shouldShowLabels ? 1 : 0.000001;
                        s.mesh.labels.forEach(label => label.scale.set(scale, scale, scale));
                        s.showLabels = shouldShowLabels;
                    }
                }
            },

            updateModalBar: () => {

                const IBCount = s.buses.filter(bus=>bus.direction === 'IB').length
                document.querySelector('#ob').innerHTML = s.buses.length - IBCount;
                document.querySelector('#ib').innerHTML = IBCount;

                document.querySelector('.bar div').style.width = 100 * IBCount / s.buses.length + '%';
            },

            updateModalRouteFocus: (stops) => {

                d3.select('#routeFocus .title')
                    .text(c.routeData[s.activeRoute[0]].title)
                // d3.select('#routeFocus')
                //     .selectAll('.stop')
                //     .data(stops)
                //     .enter()
                //     .append('div')
                //     .text(d=>d.properties.name+','+d.properties.prediction)
            }
        }


        app.init();
    </script>



    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,300' rel='stylesheet' type='text/css'>
    <script src='src/customlayer.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-selection@2"></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
</head>

</html>