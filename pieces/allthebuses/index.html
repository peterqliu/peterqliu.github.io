
<html>
<head>
    <meta charset='utf-8' />
    <title>allthebuses</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/94/three.min.js'></script>

    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.6.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.0.0/mapbox-gl.css' rel='stylesheet' />
    <style>

        :root {
            --IB: rgba(170, 51, 69, 1);
            --OB: rgba(65, 166, 178, 1);
            --inactive: hsl(48deg,17.4%,85%);
            --inactiveWeak: hsl(48deg,30%,98%);
            --inactiveTranslucent: hsla(48deg,30%,75%, 0.25);
        }

        body { 
            margin:0; 
            padding:0; 
            font-family: 'Open Sans', Verdana, sans-serif;
            overflow:hidden;
        }
        .relative {
            position: relative;
        }

        .absolute {
            position:absolute;
        }
        #map, #overlay { 
            position:absolute; 
            top:0; 
            bottom:0; 
            width:100%; 
            background:#B8C8D3;
        }
        /*#controls { position:absolute; top:0; left:0; }*/

        #back {
            z-index: 99;
            opacity:0.8;
            margin:1%;
            cursor:pointer;
            display:none;
            transition:transform 0.1s;
            transform-origin: center;
        }
        body[mode="focus"] #back {
            display:block;
        }
        #back:hover {
            transform:scale(1.25);
            opacity:1;
        }
        canvas {
            cursor:auto;
        }
        .mapboxgl-map {
            font-family: inherit
        }

        .mapboxgl-popup {
            z-index: 99;
        }
        .mapboxgl-popup-content {
            padding:20px;
            font-size:1.25em;
            border-radius: 5px;   
            color:#bbb;
            box-shadow: 0 2px 8px rgba(186, 180, 157, 1);
            pointer-events: none;
            transition:transform 0.1s;
        }

        .title {
            font-weight:100;
            font-size:1.5em;
            color:#666;
            line-height: 1.5em;
        }

        .subtitle {
            font-weight:100;
            font-size:0.75em;
            color:#666;
            line-height: 1.5em;   
        }
        .IB.highlight {
            color: var(--IB);
        }        
        .IB.directionText:after {
            content: 'Inbound'
        }        

        .OB.highlight {
            color: var(--OB);
        }
        .OB.directionText:after {
            content: 'Outbound'
        }      

        #loader {
            z-index: 99;
            width:100%;
            height:100%;
            /*display: none;*/
            backdrop-filter: blur(10px);
            position: absolute;
            pointer-events: none;
            transition:opacity 0.25s;
        }

/*        .blurred + #map{
            pointer-events: none
        }*/


        #spinner {
            z-index: 99;
            width:10vh;
            height:10vh;
            margin-left:50vw;
            margin-top:50vh;
            background: #aa3345;
            transform-origin: center;
            animation-duration: 1.2s;
            animation-iteration-count: infinite;
            transform-origin: center;
            fill-opacity:0.8;
            border-radius: 50%;
            border-top-right-radius: 0%;
            position:absolute;
            animation-name: spinner;

        }

        #modal {
            position:absolute;
            bottom:0;
            right:0;
            background:white;
            margin:2vh;
            box-shadow: 0 2px 8px rgba(186, 180, 157, 1);
            border-radius:10px;
            font-size:2em;
            z-index: 90;
            max-height:96vh;
            overflow:scroll;
        }

        .view {
            padding:30px;
        }
        .modalSmall {
            font-size: 0.5em;
            color:#aaa;
        }

        .strong {
            color:#999
        }
        .bar {
            height: 4px;
            width: 100%;
            border-radius: 2px;
            overflow: visible;
            opacity:0.8;
            margin:5px 0px;
            background: #eee;
            position:relative;
        }

        .fr {
            float: right;
        }

        #inboundBar {
            background:var(--IB);
            text-align: right;
            width: 40%;
            height: 100%;
        }

        .direction {
            position:relative;
            margin-top:8px;
        }

        .directionBar {
            background-color: var(--inactiveTranslucent);
            border-radius:4.5px;
            height:9px;
        }

        .directionLabel *:first-child:before {
            content:'← '
        }

        .directionLabel *:last-child:after {
            content:' →'
        }
        .barExtent {
            width: calc(100% - 9px);
            padding-right:9px;
        }
        .stopHash {
            width:1px;
            height:4px;
            border-radius:2px;
            background:#ccc;
            /* display:inline; */
            position:absolute;
        }


        /* marker styling is applied to an :after pseudoselector, where its styling transforms also apply.
        this lets us stack on translation transforms to the element proper, without adding a nested element */

        .marker:after {
            display: inline-block;
            content:'.';
            font-size:0em;
            width: 9px;
            height: 9px;
            border-radius: 50%;
            border-top-right-radius: 0px;
        }

        .ib.marker:after {
            background: var(--IB);
        }

        .ob.marker:after {
            background: var(--OB);
        }

        .barExtent .marker {
            width:calc(100% - 9px);
        }

        .left.marker:after {
            transform: rotate(45deg);
        }

        .right.marker:after {
            transform: rotate(45deg);
        }

        .down.marker:after {
            transform: translateY(-50%) rotate(135deg)
        }
        .big.marker:after {
            width: 22px;
            height: 22px;
        }

        #routeBuses .marker {
            position:absolute;
            left:14px;
            top:0;
        }

        .animateTransform {
            transition:transform 1s;
        }
        
        .routeStop .subtitle{
            margin:0px 25px;
        }
        .routeStop:before {
            content: '.';
            font-size: 0em;
            width:10px;
            background:var(--inactive);
            height: 200%;
            position: absolute;
            left: 20px;
            top: -50%;
            border-radius:5px;
            opacity:0.5;
        }

        .routeStop:first-child:before {
            top:calc(50% - 5px);
        }

        .routeStop:last-child:before {
            transform:translateY(calc( -75% + 5px));
            top:0;
        }

        
        .quiet {
            opacity:0.6;
        }

        @-webkit-keyframes spinner {
            0% {
                transform: translateX(-50%) translateY(-50%) rotate(0deg);
            }
            50% {
                /* transform: scale(0.8) translateX(-50%) translateY(-50%) rotate(450deg) ; */
            }
            100% {
                transform: translateX(-50%) translateY(-50%) rotate(720deg) ;
            }
        }

        #routeFocus {
            display:none;
        }
        body[mode='focus'] #routeFocus {
            display:block;
        }

        body[mode='focus'] #general {
            display:none;
        }

        .listEntry {
            border-top: 1px solid var(--inactive);
            background: var(--inactiveWeak);
            padding: 16px 20px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .listEntry:hover {
            background:white;
        }
        .listEntry .notation {
            position: absolute;
            top: 25%;
            transform: translateY(25%);
            right: 20px;
            text-align: right;
        }
        .lines {
            /* margin:2vh; */
        }
        .line {
            margin-top:15px;
        }
    </style>
    <body mode='loading'>
        <div id='loader' class='blurred'>
            <div id='spinner' ></div>
        </div>
        <div id='map'>
            <div id='modal'>
                <div id='general'>
                    <div class="view">
                        <div class='title'>Muni, this moment</div>
                        <div class='bar' style="background: var(--OB)">
                            <div id="inboundBar" class="fr"></div>
                        </div>
                        <div class='modalSmall'>
                            <span class='left ob marker'></span>
                            <span id='ob'></span> Outbound
                            <span class="fr">
                                <span id='ib'></span> 
                                Inbound 
                                <span class='right ib marker' 
                                    style=' margin-right:2px'
                                ></span>
                            </span>
                        </div>
                    </div>

                    <div id='routeList'>
                    </div>       
                </div>
         
                <div id='routeFocus'>
                    <div class='view'>
                        <div class='title' id="routeName"></div>
                        <div class='subtitle'>
                            <span id="directionText" class="directionText highlight"></span> to
                            <span id="routeDir"></span>
                        </div>
                    </div>
                    <div class="relative">
                        <div id="routeStops"></div>
                        <div id="routeBuses"></div>    
                    </div>
                </div>

            </div>            
        </div>

        <img src='src/zoomout.svg'id='back' onclick='app.setState("mode", "inactive"); app.map.fitBounds(c.fullBounds, {duration:500})'/>
    </body>
    <script src='../credentials.js'></script>

    <script src='src/map.js'></script>
    <script src="https://unpkg.com/cheap-ruler@3.0.1/cheap-ruler.min.js"></script>
    <script src="src/constants.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-selection@2"></script>
    <script src='src/modal.js'></script>
    <script>

        mapboxgl.accessToken = config.token;

        const app = {

            init: () => {
                console.log('init');
                const {pollBuses} = app;

                pollBuses(true)
                setInterval(()=>pollBuses(), 5000)



                // build marker primitive and load font
                const loader = new THREE.FontLoader();

                loader.load( 'src/Open Sans_Regular.json', font => {

                    c.font = font;
                    app.setState('initFont', true);

                } );

                const x = 0, y = 0;

                const markerShape = new THREE.Shape();
                markerShape.arc(0, 0, 1, Math.PI/2, 0, false);
                markerShape.lineTo(x+1, y+1);

                c.geometry.bus = new THREE.ShapeGeometry( markerShape );
                c.geometry.bus.matrixAutoUpdate = false;
            },

            pollBuses: (initial) => {

                app.utils.load('vehicles', (resp) => {

                    if (resp.length === 0) return
                    console.log('poll');
                    const {requestsInFlight, mode} = s;
                    s.lastPollTime = Date.now();

                    resp
                        .filter(item =>item.dir?.id)
                        .forEach(line=>{
                            if (!c.routeData[line.route.id]) {
                                c.routeData[line.route.id] = 'pending'
                                fetchRouteData(line.route.id)
                            }
                        })


                    s.buses = resp
                        .filter(item =>item.dir?.id)
                        .map(item => {
                            const {dir:{id}} = item;
                            item.direction = app.utils.getDirection(id)
                                return item
                            });

                    app.updateModalBar();

                    if (initial) {
                        if (app.map.loaded()) setupMap()
                        else app.map.on('load', () => setupMap())
                    }

                    else s.animatingBuses = true;

                    s.customLayer.updateBuses();

                    if (mode==='focus') modal.routeView.updateBuses();
                    if (!requestsInFlight) modal.systemView.updateRoutes();
                })
            },
            ruler: new CheapRuler(s.center[1], 'feet'),

            getPrediction: (route, stop, cb) => {
                const url = `stopcodes/1${stop}/predictions`;

                app.utils.load(url, (r)=>{
                    const routeMatch = r.find(prediction=>prediction.route.id===route);
                    const predictions = routeMatch.values.map(v=>({seconds:(v.timestamp-Date.now())/1000, occupancy:v.occupancyDescription}))
                    cb(predictions || undefined);
                })

            },

            format: {
                time: (seconds) => {
                    let prediction;
                    if (!seconds) prediction = 'no current prediction'
                    else if (seconds>180) return `${Math.round(seconds/60)} minutes`
                    else if (seconds>60) {
                        const [minutes, secondRemainder] = [Math.floor(seconds/60), Math.round(seconds%60)];
                        return `${minutes}:${secondRemainder<10 ? 0 :''}${secondRemainder}`
                    }
                    else if (seconds>5) return `${Math.round(seconds)} seconds`
                    else return `approaching now`
                },

                distance: (feet) => {
                    return feet > 999 ? `${(feet/5280).toFixed(2)} mi`:`${feet.toFixed(0)} ft`;
                },
                occupancyString(raw) {
                    return raw.toLowerCase().replace('room ', '')
                },

                speed(kph) {
                    return kph ? 'moving at ' +Math.round(kph*0.621371) +' mph' : 'momentarily stopped'
                },
                
                dirName(raw) {
                    if (!raw) return ''

                    // abbreviate
                    let formatted = raw
                        .replace(' from', ', from')
                        .replace('+', '&')
                        .replace(/Avenue/g, '')
                        .replace(/Street/g, '')

                    // remove if too long
                    if (formatted.length>20) formatted = formatted
                        .replace(' Ave', '')
                        .replace(' St ', '')
                    return formatted
                },

                // for an array of stops, format intersection labels such that the repeating street comes second
                sameStreetSecond(array, mapFn, outputFn) {

                    let previousStop = null;
                    let nameArray = array.map(mapFn);
                    let conjunctionString = ' & ';
                    
                    const formattedArray = nameArray.map(name=>{

                        if (name.includes(conjunctionString)) {

                            const split = name.split(conjunctionString);
                            if (previousStop?.includes(split[0])) {
                                previousStop = name;
                                return split.reverse().join(conjunctionString);
                            }

                            else {
                                previousStop = name;
                                return name
                            }
                        }

                        else {
                            previousStop = null;
                            return name
                        }
                    })

                    return array.map((d,i)=>outputFn(d, formattedArray[i]))
                }
            },

            setState: (key, value) => {
                
                if (key === 'activeRoute'){
                    s.activeBus = value;
                    const {route, direction, dir, vehiclePosition:{pathTag}} = value;
                    var newRoute = value ? [route.id, direction, dir.id, pathTag] : false
                    s.activeRoute = newRoute;
                    if (s.mode==='focus') modal.routeView.updateStops();
                        
                    updateRoute();
                }

                // inactive, active, focus modes
                else if (key === 'mode') {

                    if ([s.mode,value].includes('focus')) modal.element.scrollTop = 0;

                    s.mode = value;
                    console.warn(key, value)
                    document.querySelector('body')
                        .setAttribute('mode', value)
                        
                    // apply map styling for current mode
                    c.style[value].forEach(style => {
                        app.map.setPaintProperty(...style)
                    })

                    if (value === 'inactive') s.customLayer.restoreBusMarkerColors()
                    
                }


                else if (key.includes('init')) {

                    s[key] = value;

                    if (s.initScene === s.initFont === true) {

                        document.querySelector('#loader').style.opacity = 0

                        app.map
                            .on('mousemove', (e)=>{app.on.mouseMove(e)} )
                            .on('click', s.customLayer.onClick)
                            .on('zoom', app.on.zoom) 
                            .on('zoom', app.on.zoomEnd) 

                        }

                }
            },

            map: new mapboxgl.Map({
                container: 'map', // container id
                antialiased:true,

                style: 'mapbox://styles/peterqliu/cjnnukhkb08fu2so0ywo37ibj',
                center: s.center, // starting position
                // minZoom: 12,
                zoom: s.zoom // starting zoom
            }),

            popup: new mapboxgl.Popup({ 
                closeButton: false, 
                offset:25, 
                maxWidth:400 
            }),

            clearPopup: () => {
                app.popup.remove()
            },
            
            utils: {

                degreeify: radians =>{
                    radians = radians || 0;
                    return radians * 360/(Math.PI*2)
                },

                radify: deg => 2*Math.PI * deg/360,

                load: (queryString, cb) => {
                    const url = 'https://webservices.umoiq.com/api/pub/v1/agencies/sfmta-cis/';
                    const token = '?key=0be8ebd0284ce712a63f29dcaf7798c4';
                    s.requestsInFlight++;
                    return fetch([url, queryString, token].join(''))
                        .then(response => response.json())
                        .then(data=> {
                            s.requestsInFlight--
                            cb(data)
                        })
                },

                getDirection: str => {
                    var output = str.includes('_0_') ? 'OB' : 'IB'
                    return output
                },
                
                projectToScene: lngLat => {

                    const lng = lngLat.lng;

                    const xMercatorDelta = (lngLat[0]-s.center[0])/360;
                    const yMercatorDelta = 0.5 - 0.5 * Math.log(Math.tan(Math.PI * (1/4 + lngLat[1]/360)))/Math.PI - c.sceneTranslate.y

                    return new THREE.Vector3(xMercatorDelta, yMercatorDelta, Math.random()/10000000)
                }
            },

            on: {
                mouseMove: e => {

                    const cL = s.customLayer;

                    const mouse = new THREE.Vector3(
                        ( e.point.x / window.innerWidth ) * 2 - 1,
                        - ( e.point.y / window.innerHeight ) * 2 + 1,
                        1
                    )

                    const camInverseProjection = new THREE.Matrix4().getInverse(cL.camera.projectionMatrix);
                    const cameraPosition = new THREE.Vector3().applyMatrix4(camInverseProjection);
                    const mousePosition = mouse.applyMatrix4(camInverseProjection);
                    const viewDirection = mousePosition.clone().sub(cameraPosition).normalize();        

                    cL.raycaster.set(cameraPosition, viewDirection)
                    const [intersect] = cL.raycaster.intersectObjects( s.mesh.markers);
                    cL.highlightMarker(intersect ? intersect.object : undefined)
                
                    if (s.mode === 'focus' && !intersect) {
                        const hoveredStop = app.map
                            .queryRenderedFeatures(e.point, {layers:['stops']})[0];

                        cL.highlightStop(hoveredStop)
                        if (!hoveredStop) app.popup.remove()

                    }
                    
                },

                zoom: () =>{
                    const z = app.map.getZoom();
                    const {labelZoomThreshold} = c;
                    const shouldShowLabels = z >= labelZoomThreshold;
                    
                    if (shouldShowLabels !== s.showLabels) {
                        console.log('changing')
                        const scale = shouldShowLabels ? 1 : 0.000001;
                        s.mesh.labels.forEach(label => label.scale.set(scale, scale, scale));
                        s.showLabels = shouldShowLabels;
                    }

                    c.material.OB.uniforms.highZoomSizeAttenuation.value = shouldShowLabels ? Math.pow(0.5, z-c.labelZoomThreshold) : 1;
                },

                zoomEnd: ()=>{
                    s.mesh.markers.forEach(m=>{
                        m.geometry.boundingSphere.radius = 1.4142135623730951*s.highZoomSizeAttenuation.value
                    })
                }
            },

            updateModalBar: () => {

                const IBCount = s.buses.filter(bus=>bus.direction === 'IB').length
                document.querySelector('#ob').innerHTML = s.buses.length - IBCount;
                document.querySelector('#ib').innerHTML = IBCount;

                document.querySelector('.bar div').style.width = 100 * IBCount / s.buses.length + '%';
            },

            updateModalRouteFocus: (stops) => {

                d3.select('#routeFocus .title')
                    .text(c.routeData[s.activeRoute[0]].title)
                // d3.select('#routeFocus')
                //     .selectAll('.stop')
                //     .data(stops)
                //     .enter()
                //     .append('div')
                //     .text(d=>d.properties.name+','+d.properties.prediction)
            }
        }


        app.init();
    </script>



    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,300' rel='stylesheet' type='text/css'>
    <script src='src/customlayer.js'></script>
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>
</head>

</html>